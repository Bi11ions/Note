# 递归与迭代

递归和迭代都是循环中的一种。 

* 递归是重复调用函数自身实现循环。
*  迭代是函数内某段代码实现循环，

迭代与普通循环的区别是：

* 循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。 

递归循环中，遇到满足终止条件的情况时逐层返回来结束。

# 排序

## 各种算法性能特点

| 算法         | 是否稳定 | 是否为原地排序 | 时间复杂度        | 空间复杂度 | 备注                                               |
| ------------ | -------- | -------------- | ----------------- | ---------- | -------------------------------------------------- |
| 选择排序     | 否       | 是             | N^2               | 1          |                                                    |
| 插入排序     | 是       | 是             | N~N^2             | 1          | 取决于输入元素的排序情况                           |
| 希尔排序     | 否       | 是             | N*logN ？ ~ N^6/5 | 1          |                                                    |
| 快速排序     | 否       | 是             | N*logN            | lgN        | 运行效率由概率提供保证                             |
| 三向快速排序 | 否       | 是             | N ~ N*logN        | lgN        | 运行效率由概率保证，同时也取决于输入元素的分布情况 |
| 归并排序     | 是       | 否             | N*logN            | N          |                                                    |
| 堆排序       | 否       | 是             | N*logN            | 1          |                                                    |

## 快速排序是最快的通用排序算法

自从数十年前快速排序发明以来，它在无数计算机系统中的无数实现已经证明了这一点。 总的来说，快速排序之所以最快是因为它的内循环中的指令很少（而且它还能利用缓存，因为 它总是顺序地访问数据），所以它的运行时间的增长数量级为 ~cNlgN，而这里的 c 比其他线性 对数级别的排序算法的相应常数都要小。在使用三向切分之后，快速排序对于实际应用中可能 出现的某些分布的输入变成线性级别的了，而其他的排序算法则仍然需要线性对数时间



# 查找

## 符号表的各种实现的优缺点

| 使用的数据结构     | 实现                                         | 优点                                             | 缺点                                                         |
| ------------------ | -------------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------ |
| 链表（顺序结构）   | SequentialSearchST                           | 适用小型问题                                     | 对于大型符号表很慢                                           |
| 有序数组（二分法） | BinarySearchST                               | 最优的查找效率和空间需求，能够进行有序性相关操作 | 插入操作很慢                                                 |
| 二叉查找树         | BST                                          | 实现简单，能够进行有序性相关操作                 | 没有性能上界的保证，链接需要额外的空间                       |
| 平衡二叉查找树     | RedBlackBST                                  | 最优的查找和插入效率，能够进行有序性相关的操作   | 链接需要额外的空间                                           |
| 散列表             | SeparateChainHashST<br />LinearProbingHashST | 能够快速地查找和插入常见类型的数据               | 需要计算各种类型的数据的散列<br />无法进行有序性相关性操作<br />链接和空节点需要额外的空间 |

## 二叉查找树

> 一棵二叉查找树（BST）是一棵二叉树，其中每个结点都含有一个 Comparable 的键（以 及相关联的值）且**每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点 的键。**

证以下公式对于二叉树中的任意结点 x 总是成立。

 ```
size(x) = size(x.left) + size(x.right) + 1
 ```

>  **递归调用**：
>
> **将递归调用前的代码想象成沿着树向下走**：它会将给定的键和每个结点的键相比较并根据结果向左或者向 右移动到下一个结点。
>
> **将递归调用后的代码想象成 沿着树向上爬。**

### 递归与非递归实现的优缺点

* 递归实现更容易验证其正确性，并且容易实现和调试

* 非递归实现的效率更高，如果树不是平衡的，函数调用的栈的升读可能会成为递归实现的一个问题\

### 深度优先遍历

* 先序遍历：先访问根节点，再依次访问左子树和右子树
* 中序遍历：先访问左子树，再访问根节点吗，最后访问右子树
* 后序遍历：先访问左子树，再访问右子树，最后访问根节点

### 广度优先遍历

* 按照树的深度，一层一层的访问树的节点

## 简单的符号表实现的成本总结

| 算法（数据结构）         | 查找（最坏） | 插入（最坏） | 查找（平均） | 插入（平均） | 是否支持有序性相关操作 |
| ------------------------ | :----------: | :----------: | :----------: | :----------: | :--------------------: |
| 顺序查询（无序链表）     |      N       |      N       |     N/2      |      N       |           否           |
| 二分查找（有序数组）     |     lgN      |      N       |     lgN      |     N/2      |           是           |
| 二叉树查找（二叉查找树） |      N       |      N       |   1.39lgN    |   1.39lgN    |           是           |
| 红黑树                   |     2lgN     |     2lgN     |   1.00lgN    |   1.00lgN    |           是           |

## 红黑树

> 1. 红链接均为左链接； 
> 2. 没有任何一个结点同时和两条红链接相连； 
> 3. 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。 
> 4. 根节点总是黑色的

### 左旋转

如果存在一条红色的右链接，则需要将其转化为左连接，这一过程称之为左旋转

### 恢复平衡过程

1. 如果右子结点是红色的而左子结点是黑色 的，进行左旋转； 
2. 如果左子结点是红色的且它的左子结点也是红色的，进行右旋转； 
3. 如果左右子结点均为红色，进行颜色转换。

## 二叉树解题框架

```Java
void traverse(TreeNode root) {
    // 前序遍历-操作在这
    traverse(root.left)
    // 中序遍历-操作在这
    traverse(root.right)
    // 后序遍历-操作在这
}
```

