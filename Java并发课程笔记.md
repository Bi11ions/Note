## Java 内存模型

### 同步的八种操作

* **lock**(锁定)：作用于主内存的变量，把一个变量表示为一条线程独占状态
* **unlock**(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放出来的变量才可以被其他线程锁定
* **read**(读取)：作用于主内存的变量，把一个变量值从主内存中传输到线程的工作内存中，以便随后的load操作使用
* **load**(载入)：作用于主内存的变量，它把 read 操作从主内存中的变量值放入工作内存中的变量副本中。
* **use**(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎
* **assign**(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量
* **store**(存储)：作用于工作内存的变量，它把工作内存中的一个变量的值送到主内存中，以便随后的 write 操作
* **write**(写入)：作用于主内存的变量，它把 store 操作从工作内存中一个变量值传入到主内存的变量中

### 同步规则

* 如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行 read 和 load 操作，如果把变量从工作内存中同步回主内存中，就需要按顺序地执行 store 和 write 操作。但 Java 内存模型只要求上述操作必须按顺序执行，而没有要求必须是连续执行的。
* 不允许 read 和 load、store 和 write 操作之一单独出现，必须两两出现
* 不允许一个线程丢弃它的最近的 assign 的操作，即变量在工作内存中改变了之后必须同步到主内存中。
* 不允许一个线程无原因的（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中
* 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实时 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。
* 一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行后，只有执行相同次数的 unlock 操作，变量才会被解锁。lock 和 unlock 必须成对出现。
* 如果对一个变量执行 lock 操作，将会清空工作内存中次变量的值，在执行引擎使用这个变量前需重新执行 load 或 assign 操作初始化变量的值
* 如果一个变量实现没有被 lock 操作锁定，则不允许对它执行 unlock 操作；也不允许去 unlock 一个被其他线程锁定的变量
* 对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）

![](E:\Code\Note\image\concurrent\Java内存模型同步操作与规则.png)

