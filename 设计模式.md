# 设计模式

## 单例模式

单例模式是 Java 中最简单，也是最基础，最常用的设计模式之一。在运行期间，保证某个类只创建一个实例，保证一个类仅有一个实例，并提供一个访问它的全局访问点。

### 饿汉式

这种写法，在类被加载的时候就把Singleton实例给创建出来了。

```java
public class Singleton {

    private static Singleton instance = new Singleton();

    private Singleton() {
    }

    public static Singleton getInstance() {
        return instance;
    }

}
```

### **懒汉式**

在真正需要的时候再去创建实例。在getInstance方法中，先判断实例是否为空再决定是否去创建实例，看起来似乎很完美，但是存在线程安全问题。在并发获取实例的时候，可能会存在构建了多个实例的情况。

```java
public class Singleton {
    
    private static Singleton instance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
    
}
```

### DCL双重检测加锁(进阶懒汉式)

对懒汉式单例模式做了线程安全处理。通过加锁，可以保证同时只有一个线程走到第二个判空代码中去，这样保证了只创建 一个实例。这里还用到了volatile关键字来修饰singleton，其最关键的作用是防止指令重排。

```java
public class SingletonSafe {

    private static volatile SingletonSafe singleton;

    private SingletonSafe() {
    }

    public static SingletonSafe getSingleton() {
        if (singleton == null) {
            synchronized (SingletonSafe.class) {
                if (singleton == null) {
                    singleton = new SingletonSafe();
                }
            }
        }
        return singleton;
    }
}
```

### 静态内部类

通过静态内部类的方式实现单例模式是线程安全的，同时静态内部类不会在Singleton类加载时就加载，而是在调用getInstance()方法时才进行加载，达到了懒加载的效果。

缺点：可能还存在反射攻击或者反序列化攻击。

```java
public class Singleton {

    private static class SingletonHolder {
        private static Singleton instance = new Singleton();
    }

    private Singleton() {
        
    }

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }
}
```

**反射攻击**：

```java
public static void main(String[] args) throws Exception {
    Singleton singleton = Singleton.getInstance();
    Constructor<Singleton> constructor = Singleton.class.getDeclaredConstructor();
    constructor.setAccessible(true);
    Singleton newSingleton = constructor.newInstance();
    System.out.println(singleton == newSingleton); // 运行结果 false
}
```

**反序列化攻击**

这里借助使用 commons 包工具类实现反序列化

```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.8.1</version>
</dependency>
```

```java
public class Singleton implements Serializable {

    private static class SingletonHolder {
        private static Singleton instance = new Singleton();
    }

    private Singleton() {

    }

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }

    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        byte[] serialize = SerializationUtils.serialize(instance);
        Singleton newInstance = SerializationUtils.deserialize(serialize);
        System.out.println(instance == newInstance); // 结果 false
    }

}
```

### 枚举

在effective java（这本书真的很棒）中说道，最佳的单例实现模式就是枚举模式。利用枚举的特性，**让JVM来帮我们保证线程安全和单一实例的问题**。除此之外，写法还特别简单。

可以**防止多次实例化**，即使是在面对复杂的序列化或者反射攻击的时候(安全)！

# **23种设计模式**

### 1.设计模式的六大原则

+ [《设计模式的六大原则》](https://blog.csdn.net/q291611265/article/details/48465113)

  + 开闭式原则：对拓展开放，对修改关闭，多使用抽象类和接口。

  + 里氏替换原则：基类可以被子类替换，使用抽象类继承而不是用具体类继承

  + 依赖倒转原则：要依赖于抽象，而不依赖于具体，针对接口编程，不针对实现编程

  + 接口隔离原则：使用多个隔离的接口，比使用单个的好，建立最小的接口

  + 迪米特法则：一个软件实体应当尽可能少于其他实体发生相互作用，建立中间类联系

  + 合成复用法则：尽量使用合成/聚合，而不使用继承


### 2. 23种常用的设计模式

+ [《设计模式》-菜鸟教程](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)
+ [《23种设计模式》-博客](https://www.cnblogs.com/susanws/p/5510229.html)
+ [《设计模式类图与示例》-GitHub](https://github.com/ToryZhou/design-pattern)

#### Java 的设计模式大体上分为三类:

- **创建型模式**（5种）：①简单工厂模式、②抽象工厂模式、③单例模式、④建造者模式、       ⑤原型模式
- **结构型模式**（7种）：①适配器模式、②装饰器模式、③代理模式、④外观模式、⑤桥接模式、⑥组合模式、⑦享元模式
- **行为型模式**（11种）：a.策略模式、b.模板方法模式、c.观察者模式、d.迭代子模式、e.责任链模式、f.命令模式、g.备忘录模式、h.状态模式、i.访问者模式、j.中介者模式、k.解释器模式

#### A. 创建模式(5种) :

	①简单工厂模式、②抽象工厂模式、③单例模式、④建造者模式、⑤原型模式 

##### 1. 简单工厂模式 -- 主要使用静态工厂模式(Static Factory)

工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

**何时使用：**我们明确地计划不同条件下创建不同实例时。

**应用实例：** 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。

```java
interface Food {
}

class A implements Food {}
class B implements Food {}
class C implements Food {}

// 用户不需要了解工厂类内部的逻辑
public class StaticSimpleFactory {
    public static Food getA() {
        return new A();
    }
    public static Food getB() {
        return new B();
    }
    public static Food getC() {
        return new C();
    }
}

class Client {
    // 客户端代码，只需要将相应的参数传入即可得到对象
    public static void main(String[] args) {
        // 不需要实例化工厂类，直接使用获取的方式创建对象
        Food food = StaticSimpleFactory.getA();
        System.out.println(food instanceof A);
    }
```



##### 2. 抽象工厂模式(Abstract Factory)

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

**何时使用：**系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

**应用实例：**工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。

```java
public interface Produce {
    Food get();
}
```

```java
// 每个工厂都可以有自己的生产模式
public class FactoryA implements  Produce {
    @Override
    public Food get() {
        return new A();
    }
}

```

```java
public class AbstractFactory {
    // 客户端可以直接通过新建工厂实例来获得指定实例
    public static void main(String[] args) {
        Food food = new FactoryA().get();
        food = new FactoryB().get();
        food = new FactoryC().get();
    }
}
```



##### 3. 单例模式(Singleton)

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

**注意**：

- 单例类只能有一个实例；

- 单例类必须自己创建自己的实例；

+ 单例类必须给其他对象获取实例的方法

**何时使用：**当您想控制实例数目，节省系统资源的时候。

**应用实例：** 1、一个党只能有一个书记。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。

```java
public class Singleton {
    /* 持有私有静态实例，防止被引用，此处值为 null，目的是实现延迟加载 */
    private static Singleton instance = null;

    /* 私有化构造方法，防止被实例化 */
    private Singleton() {
    }

    /* 静态方法，用来获取实例 */
    public static Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }

    /* 如果该对象被用于序列化，该方法可以保证对象在序列化前后保持一致 */
    public Object readResolve() {
        return instance;
    }
}
```



##### 4. 建造者模式(Builder)

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

**何时使用：**一些基本部件不会变，而其组合经常变化的时候。

**应用实例：** 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、JAVA 中的 StringBuilder。

```java
// 实体类
public class Student {
    String name = null;
    int number = -1;
    String sex = null;
    int age = -1;
    String school = null;
	// 用于 Builder 的构造方法
    public Student(StudentBuilder builder) {
        this.name = builder.name;
        this.number = builder.number;
        this.sex = builder.sex;
        this.age = builder.age;
        this.school = builder.school;
    }
}
```

```java
// 实体建造类
public class StudentBuilder {
    String name = null;
    int number = -1;
    String sex = null;
    int age = -1;
    String school = null;
	
    // 每一个 set 方法都会返回 Builder 类，以供可以继续 set 或者 执行 build 方法
    public StudentBuilder setName(String name) {
        this.name = name;
        return this;
    }

    public StudentBuilder setNumber(int number) {
        this.number = number;
        return this;
    }

    public StudentBuilder setSex(String sex) {
        this.sex = sex;
        return this;
    }

    public StudentBuilder setAge(int age) {
        this.age = age;
        return this;
    }

    public StudentBuilder setSchool(String school) {
        this.school = school;
        return this;
    }
	// 最后实例化，返回实例对象
    public Student build() {
        return new Student(this);
    }
}
```

```java
public class Builder {
    public static void main(String[] args) {
        // 实体可以有建造类来一个一个添加属性，最后调用 build 方法返回该实例化对象
        Student a = new StudentBuilder().setName("a").build();
        System.out.println(a.name);
    }

}

```



##### 5. 原型模式(Prototype)

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。**当直接创建对象的代价比较大时，则采用这种模式。**例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

**何时使用：** 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

**应用实例：** 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。

**实现：**

在Java中，复制对象是通过clone()实现的，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的.

```java
public class Prototype implements Cloneable {
    public Object clone() throws CloneNotSupportedException {
        Prototype proto = (Prototype)super.clone();
        return proto;
    }
}

```



首先需要了解**对象深**、**浅复制**的概念：

***浅复制***：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。

***深复制***：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。

```java
public class Prototype implements Cloneable, Serializable {

    private static final long serialVersionUID = 5001189396036280066L;
    private String string;

    private SerializableObject obj;

    /*浅复制*/
    public Object clone() throws CloneNotSupportedException {
        Prototype proto = (Prototype) super.clone();
        return proto;
    }

    /*
     * 深复制 :  要实现深复制，需要采用流的形式写入当前对象的二进制流，
     *          再写出二进制数据对应的对象
     */
    public Object deepClone() throws IOException, ClassNotFoundException{
        /*写入当前对象的二进制流*/
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(this);

        /*读出二进制流产生的新对象*/
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        return ois.readObject();
    }

    public String getString() {
        return string;
    }

    public void setString(String string) {
        this.string = string;
    }

    public SerializableObject getObj() {
        return obj;
    }

    public void setObj(SerializableObject obj) {
        this.obj = obj;
    }
}

class SerializableObject implements  Serializable {
    private static final long serialVersionUID = -3842420135420221679L;
}

```

#### B. 结构模式(7种)

	①适配器模式、②装饰器模式、③代理模式、④外观模式、⑤桥接模式、⑥组合模式、⑦享元模式


##### 6. 适配器模式(Adapter)

适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。

主要分为三类：

+ 类的适配器模式：创建新类，继承源类，并实现新接口，

  **核心思想**就是：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里。例如：

  ```java
  class adapter extends Source implements Targetable{}
  
  ```

+ 对象的适配器模式：创建新类持源类的实例，并实现新接口，

  基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。例如：

  ```java
  class adapter implements Targetable { private Source source ;}
  
  ```

+ 接口的适配器模式：创建新的抽象类实现旧接口方法。

  **接口的适配器**：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。

  例如：

  ```java
  abstract class adapter implements oldClassFunc { void newFunc();}
  
  ```

**实现：**

	我们有一个 MediaPlayer 接口和一个实现了 MediaPlaye 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。
	
	我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。
	
	我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。
	
	AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo，我们的演示类使用 AudioPlayer 类来播放各种格式。


```java
// 为媒体播放器和更高级的媒体播放器创建接口。
public interface MediaPlayer {
   public void play(String audioType, String fileName);
}

public interface AdvancedMediaPlayer { 
   public void playVlc(String fileName);
   public void playMp4(String fileName);
}

```

```java
// 创建实现了 AdvancedMediaPlayer 接口的实体类。
public class VlcPlayer implements AdvancedMediaPlayer{
   @Override
   public void playVlc(String fileName) {
      System.out.println("Playing vlc file. Name: "+ fileName);      
   }
 
   @Override
   public void playMp4(String fileName) {
      //什么也不做
   }
}

public class Mp4Player implements AdvancedMediaPlayer{
 
   @Override
   public void playVlc(String fileName) {
      //什么也不做
   }
 
   @Override
   public void playMp4(String fileName) {
      System.out.println("Playing mp4 file. Name: "+ fileName);      
   }
}

```

```java
// 创建实现了 MediaPlayer 接口的适配器类。
public class MediaAdapter implements MediaPlayer {
 
   AdvancedMediaPlayer advancedMusicPlayer;
 
   public MediaAdapter(String audioType){
      if(audioType.equalsIgnoreCase("vlc") ){
         advancedMusicPlayer = new VlcPlayer();       
      } else if (audioType.equalsIgnoreCase("mp4")){
         advancedMusicPlayer = new Mp4Player();
      }  
   }
 
   @Override
   public void play(String audioType, String fileName) {
      if(audioType.equalsIgnoreCase("vlc")){
         advancedMusicPlayer.playVlc(fileName);
      }else if(audioType.equalsIgnoreCase("mp4")){
         advancedMusicPlayer.playMp4(fileName);
      }
   }
}

```

```java
// 创建实现了 MediaPlayer 接口的实体类。
public class AudioPlayer implements MediaPlayer {
   MediaAdapter mediaAdapter; 
 
   @Override
   public void play(String audioType, String fileName) {    
 
      //播放 mp3 音乐文件的内置支持
      if(audioType.equalsIgnoreCase("mp3")){
         System.out.println("Playing mp3 file. Name: "+ fileName);         
      } 
      //mediaAdapter 提供了播放其他文件格式的支持
      else if(audioType.equalsIgnoreCase("vlc") 
         || audioType.equalsIgnoreCase("mp4")){
         mediaAdapter = new MediaAdapter(audioType);
         mediaAdapter.play(audioType, fileName);
      }
      else{
         System.out.println("Invalid media. "+
            audioType + " format not supported");
      }
   }   
}

```

```java
//使用 AudioPlayer 来播放不同类型的音频格式。
public class AdapterPatternDemo {
   public static void main(String[] args) {
      AudioPlayer audioPlayer = new AudioPlayer();
 
      audioPlayer.play("mp3", "beyond the horizon.mp3");
      audioPlayer.play("mp4", "alone.mp4");
      audioPlayer.play("vlc", "far far away.vlc");
      audioPlayer.play("avi", "mind me.avi");
   }
}

```



##### 7. 装饰模式(Decorator)

装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。

**何时使用：**在不想增加很多子类的情况下扩展类。

**应用实例：** 1、孙悟空有 72 变，当他变成"庙宇"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。

**实现：**

Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能，代码如下：

```java
public interface Sourceable {
    public void method();
}

```

```java
// 被装饰类
public class Source implements Sourceable {
    @Override
    public void method() {
        System.out.println("this is original method!");
    }
}

```

```java
// 装饰类
public class Decorator implements Sourceable {
    private Sourceable source;

    public Decorator(Sourceable source) {
        super();
        this.source = source;
    }

    @Override
    public void method() {
        System.out.println("before decorator ----");
        source.method();
        System.out.println("after decorator ----");
    }
}

```

```java
// 测试类
public class DecoratorTest {
    public static void main(String[] args) {
        Sourceable source = new Source();
        Sourceable obj = new Decorator(source);
        obj.method();
    }
}
/*
 *输出结果:
 *	before decorator ----
 *	this is original method!
 *	after decorator ----
 */

```



##### 8. 代理模式(Proxy)

客户端通过代理类访问，代理类实现具体的实现细节，客户只需要使用代理类即可实现操作。

这种模式可以对旧功能进行代理，用一个代理类调用原有的方法，且对产生的结果进行控制。

**何时使用：**想在访问一个类时做一些控制。

**应用实例：** 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。

**代理模式的应用场景**：

如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：

1. 修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。

2. 就是**采用一个代理类调用原有的方法**，且对产生的结果进行控制。这种方法就是代理模式。

使用代理模式，可以将功能划分的更加清晰，有助于后期维护！

```java
public class Proxy implements Sourceable {

    private Source source;

    public Proxy() {
        this.source = new Source();
    }

    @Override
    public void method() {
        before();
        source.method();
        after();
    }

    private void after() {
        System.out.println("After Proxy");
    }

    private void before() {
        System.out.println("Before Proxy");
    }
}

```

```java
public class ProxyTest {
    public static void main(String[] args) {
        Sourceable source = new Proxy();
        source.method();
    }
}
/**
 * 输出结果：
 * Before Proxy
 * this is original method!
 * After Proxy
 */

```



##### 9. 外观模式(Facade)

外观模式是为了解决类与类之家的依赖关系的，像[spring](http://lib.csdn.net/base/17)一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口。

**何时使用：** 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口。

**应用实例：** 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。

**实现**：

	下面把 CPU、Memory、Disk 的关系集成到 Computer 类中。


```java
public class CPU {
    public void startup() {
        System.out.println("CPU startup!");
    }

    public void shutdown() {
        System.out.println("CPU shutdown!");
    }
}

```

```java
public class Memory {
    public void startup() {
        System.out.println("Memory startup!");
    }

    public void shutdown() {
        System.out.println("Memory shutdown!");
    }
}

```

```java
public class Disk {
    public void startup() {
        System.out.println("Disk startup!");
    }

    public void shutdown() {
        System.out.println("Disk shutdown!");
    }
}

```

```java
public class Computer {
    private CPU cpu;
    private Memory memory;
    private Disk disk;

    public Computer(){
        cpu = new CPU();
        memory = new Memory();
        disk = new Disk();
    }

    public void startup() {
        System.out.println("Start the computer ....");
        cpu.startup();
        memory.startup();
        disk.startup();
        System.out.println("Start the computer finished!");
    }

    public void shutdown() {
        System.out.println("Shutdown the computer ....");
        cpu.shutdown();
        memory.shutdown();
        disk.shutdown();
        System.out.println("computer shutdown finished!");
    }
}

```

```java
// 用户类，用来测试，只需要对 Computer 类进行操作，就可以看到 CPU、Memory、Disk 的关系
public class User {
    public static void main(String[] args) {
        Computer computer = new Computer();
        computer.startup();
        System.out.println("---------------");
        computer.shutdown();
    }
}
/**
 * 输出结果：
 * Start the computer ....
 * CPU startup!
 * Memory startup!
 * Disk startup!
 * Start the computer finished!
 * ---------------
 * Shutdown the computer ....
 * CPU shutdown!
 * Memory shutdown!
 * Disk shutdown!
 * computer shutdown finished!
 */

```



##### 10. 桥接模式(Bridge)

桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。

**何时使用：**实现系统可能有多个角度分类，每一种角度都可能变化。

**应用实例：** 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。

**实现**：

我们有一个作为桥接实现的 *DrawAPI* 接口和实现了 *DrawAPI* 接口的实体类 *RedCircle*、*GreenCircle*。*Shape* 是一个抽象类，将使用 *DrawAPI* 的对象。*BridgePatternDemo*，我们的演示类使用 *Shape* 类来画出不同颜色的圆。

```java
// 创建桥接实现接口。
public interface DrawAPI {
    public void drawCircle(int radius, int x, int y);
}

```

```java
// 创建实现了 DrawAPI 接口的实体桥接实现类。
public class RedCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println("Drawing Circle[ color: red, radius: "
         + radius +", x: " +x+", "+ y +"]");
   }
}
public class GreenCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println("Drawing Circle[ color: green, radius: "
         + radius +", x: " +x+", "+ y +"]");
   }
}

```

```java
//使用 DrawAPI 接口创建抽象类 Shape。
public abstract class Shape {
   protected DrawAPI drawAPI;
   protected Shape(DrawAPI drawAPI){
      this.drawAPI = drawAPI;
   }
   public abstract void draw();  
}

```



```java
// 创建实现了 Shape 接口的实体类。
public class Circle extends Shape {
   private int x, y, radius;
 
   public Circle(int x, int y, int radius, DrawAPI drawAPI) {
      super(drawAPI);
      this.x = x;  
      this.y = y;  
      this.radius = radius;
   }
 
   public void draw() {
      drawAPI.drawCircle(radius,x,y);
   }
}

```

```java
//使用 Shape 和 DrawAPI 类画出不同颜色的圆。
public class BridgePatternDemo {
   public static void main(String[] args) {
      Shape redCircle = new Circle(100,100, 10, new RedCircle());
      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());
 
      redCircle.draw();
      greenCircle.draw();
   }
}
/*
 * 输出结果：
 * Drawing Circle[color : red, radius : 10, x : 100, y : 100]
 * Drawing Circle[color : green, radius : 10, x : 100, y : 100]
 */

```



##### 11. 组合模式(Composite)

组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

**何时使用：** 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

**应用实例：** 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。

**使用场景**：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，树，文件夹等。 

```java
abstract class component{}

class File extends component{ String filename;}

class Folder extends component{
 	component[] files ; //既可以放文件File类，也可以放文件夹Folder类。Folder类下又有子文件或子文件夹。
	String foldername ;
 	
    public Folder(component[] source){ 
        files = source ;
    }
 
    public void scan(){
         for ( component f:files){
             if ( f instanceof File){
             System.out.println("File "+((File) f).filename);
             }else if(f instanceof Folder){
             Folder e = (Folder)f ;
             System.out.println("Folder "+e.foldername);
             e.scan();
             }
         }
 	}
}

```



##### 12. 享元模式(Flyweight)

享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

**何时使用：** 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。

**应用实例：** 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。

**实现：**

> 我们将创建一个 *Shape* 接口和实现了 *Shape* 接口的实体类 *Circle*。下一步是定义工厂类 *ShapeFactory*。
>
> *ShapeFactory* 有一个 *Circle* 的 *ConcurrentHashMap*，其中键名为 *Circle* 对象的颜色。无论何时接收到请求，都会创建一个特定颜色的圆。*ShapeFactory* 检查它的 ConcurrentHashMap 中的 circle 对象，如果找到 *Circle* 对象，则返回该对象，否则将创建一个存储在 ConcurrentHashMap 中以备后续使用的新对象，并把该对象返回到客户端。
>
> *FlyWeightPatternDemo*，我们的演示类使用 *ShapeFactory* 来获取 *Shape* 对象。它将向 *ShapeFactory* 传递信息（*red / green / blue/ black / white*），以便获取它所需对象的颜色。	


```java
public interface Shape {
    void draw();
}

```

```java
public class Circle implements Shape {
    private String color;
    private int x;
    private int y;
    private int radius;

    public Circle(String color) {
        this.color = color;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public int getRadius() {
        return radius;
    }

    public void setRadius(int radius) {
        this.radius = radius;
    }

    @Override
    public void draw() {
        System.out.println("Circle: Draw() [Color : " + color
                +", x : " + x +", y :" + y +", radius :" + radius);
    }
}

```

```java
// 创建一个工厂，生成基于给定信息的实体类的对象。
public class ShapeFactory {
   /**
     * ShapeFactory 有一个 Circle 的 ConcurrentHashMap，其中键名为 Circle 对象的颜色。无论何时接收到请求，都会创建一个特定颜色的圆。
     * ShapeFactory 检查它的 ConcurrentHashMap 中的 circle 对象，如果找到 Circle 对象，则返回该对象，否则将创建一个存储在 ConcurrentHashMap 中
     * 以备后续使用的新对象，并把该对象返回到客户端。
     */
    private static final ConcurrentHashMap<String, Shape> circleMap = new ConcurrentHashMap<>();

    public static Shape getCircle(String color) {
        Circle circle = (Circle) circleMap.get(color);
        if(circle == null) {
            circle = new Circle(color);
            circleMap.put(color, circle);
            System.out.println("Creating circle of color : " + color);
        }

        return circle;
    }
}

```

```java
// 使用该工厂，通过传递颜色信息来获取实体类的对象。
public class FlyweightPatternDemo {
    private static final String colors[] = {"Red", "Green", "Blue", "White", "Black"};

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            Circle circle = (Circle) ShapeFactory.getCircle(getRandomColor());
            circle.setX(getRandomX());
            circle.setY(getRandomY());
            circle.setRadius(100);
            circle.draw();
        }
    }

    private static int getRandomY() {
        return (int) (Math.random() * 100);
    }

    private static int getRandomX() {
        return (int) (Math.random() * 100);
    }

    private static String getRandomColor() {
        return colors[(int) (Math.random() * colors.length)];
    }
}
/**
 * 输出结果：
 * Creating circle of color : Blue
 * Circle: Draw() [Color : Blue, x : 71, y :70, radius :100
 * Creating circle of color : Black
 * Circle: Draw() [Color : Black, x : 78, y :92, radius :100
 * Creating circle of color : Red
 * Circle: Draw() [Color : Red, x : 56, y :70, radius :100
 * Circle: Draw() [Color : Red, x : 27, y :73, radius :100
 * Creating circle of color : White
 * Circle: Draw() [Color : White, x : 17, y :54, radius :100
 * Circle: Draw() [Color : Blue, x : 14, y :87, radius :100
 * Creating circle of color : Green
 * Circle: Draw() [Color : Green, x : 75, y :57, radius :100
 * Circle: Draw() [Color : Blue, x : 28, y :25, radius :100
 * Circle: Draw() [Color : Red, x : 28, y :52, radius :100
 * Circle: Draw() [Color : Blue, x : 88, y :91, radius :100
 */

```



#### C. 行为型模式(11种)

1. 第一类：通过父类与子类的关系进行实现。

   + 策略模式

   + 模板方法模式

2. 第二类：两个类之间。

   + 观察者模式
   + 迭代子模式
   + 责任链模式
   + 命令模式

3. 第三类：类的状态。

   + 备忘录模式
   + 状态模式

4. 第四类：通过中间类

   + 访问者模式
   + 中介者模式
   + 解释器模式



**父类与子类的关系**

##### 13. 策略模式(strategy)

策略模式定义了一系列[算法](http://lib.csdn.net/base/31)，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数。

**何时使用：**一个系统有许多许多类，而区分它们的只是他们直接的行为。

**应用实例：** 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。

**实现**：

我们将创建一个定义活动的 *Strategy* 接口和实现了 *Strategy* 接口的实体策略类。*Context* 是一个使用了某种策略的类。

*StrategyPatternDemo*，我们的演示类使用 *Context* 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。

```java
public interface Strategy {
    int doOperation(int num1, int num2);
}

```

```java
public class OperationAdd implements Strategy{
    @Override
    public int doOperation(int num1, int num2) {
        return num1 + num2;
    }
}
public class OperationMultiply implements Strategy{
    @Override
    public int doOperation(int num1, int num2) {
        return num1 * num2;
    }
}
public class OperationSubstract implements Strategy{
    @Override
    public int doOperation(int num1, int num2) {
        return num1 - num2;
    }
}

```

```java
//Context 是一个使用了某种策略的类。
public class Context {
    private Strategy strategy;
	// 构造方法是传入策略
    public Context(Strategy strategy) {
        this.strategy = strategy;
    }
	// 执行策略
    public int executeStrategy(int num1, int num2) {
        return strategy.doOperation(num1, num2);
    }
}

```

```java
public class StrategyPatternDemo {
    public static void main(String[] args) {
        Context context = new Context(new OperationAdd());
        System.out.println("10 + 5 = " + context.executeStrategy(10, 5));

        context = new Context(new OperationSubstract());
        System.out.println("10 - 5 = " + context.executeStrategy(10, 5));

        context = new Context(new OperationMultiply());
        System.out.println("10 * 5 = " + context.executeStrategy(10, 5));
    }
}
/**
 * 运行结果：
 * 10 + 5 = 15
 * 10 - 5 = 5
 * 10 * 5 = 50
 */

```



##### 14. 模板模式(Template)

在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。

**何时使用：**有一些通用的方法。

**应用实例：** 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。

**实现**：

	我们将创建一个定义操作的 *Game* 抽象类，其中，模板方法设置为 final，这样它就不会被重写。*Cricket* 和 *Football* 是扩展了 *Game* 的实体类，它们重写了抽象类的方法。
	
	TemplatePatternDemo，我们的演示类使用 *Game* 来演示模板模式的用法。


```java
public abstract class Game {
    abstract void initialize();
    abstract void startPlay();
    abstract void endPlay();

    // 模板
    public final void play() {
        // 1. 初始化游戏
        initialize();
        // 2. 开始游戏
        startPlay();
        // 3. 结束游戏
        endPlay();
    }
}

```

```java
public class Cricket extends Game{

    @Override
    void initialize() {
        System.out.println("Cricket Game Initialized! Start playing.");
    }

    @Override
    void startPlay() {
        System.out.println("Cricket Game Started. Enjoy the game!");
    }

    @Override
    void endPlay() {
        System.out.println("Cricket Game Finished!");
    }
}

public class Football extends Game {
    @Override
    void initialize() {
        System.out.println("Football Game Initialized! Start playing.");
    }

    @Override
    void startPlay() {
        System.out.println("Football Game Started. Enjoy the game!");
    }

    @Override
    void endPlay() {
        System.out.println("Football Game Finished!");
    }
}

```

```java
public class TemplatePatternDemo {
    public static void main(String[] args) {
        Game game = new Cricket();
        game.play();
        System.out.println("-----------");
        game = new Football();
        game.play();
    }
}
/**
 * 输出结果：
 * Cricket Game Initialized! Start playing.
 * Cricket Game Started. Enjoy the game!
 * Cricket Game Finished!
 * -----------
 * Football Game Initialized! Start playing.
 * Football Game Started. Enjoy the game!
 * Football Game Finished!
 */

```



**类之间的关系**

##### 15. 观察者模式(Observer)

当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。

**何时使用：**一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。

**应用实例：** 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。

**实现**：

	观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 *Subject* 类、*Observer* 抽象类和扩展了抽象类 *Observer* 的实体类。
	
	*ObserverPatternDemo*，我们的演示类使用 *Subject* 和实体类对象来演示观察者模式。


```java
public class Subject {
    private List<Observer> observers = new ArrayList<>();
    private int state;

    public int getState() {
        return state;
    }

    public void setState(int state) {
        this.state = state;
        // 重要是这里，改变了 state 变量后，通知其他观察者都改变 state 变量!
        notifyAllObservers();
    }

    public void attach(Observer observer) {
        observers.add(observer);
    }

    public void notifyAllObservers() {
        for (Observer observer : observers) {
            observer.update();
        }
    }
}

```

```java
public abstract class Observer {
    protected Subject subject;
    public abstract void update();
}

```

```java
//创建实体观察者类。
public class BinaryObserver extends Observer{
    public BinaryObserver(Subject subject) {
        this.subject = subject;
        this.subject.attach(this);
    }

    @Override
    public void update() {
        System.out.println("Binary String: "
                + Integer.toBinaryString( subject.getState()));
    }
}
public class OctalObserver extends Observer {
    public OctalObserver (Subject subject) {
        this.subject = subject;
        this.subject.attach(this);
    }

    @Override
    public void update() {
        System.out.println( "Octal String: "
                + Integer.toOctalString( subject.getState() ) );
    }
}
public class HexaObserver extends Observer {
    public HexaObserver(Subject subject){
        this.subject = subject;
        this.subject.attach(this);
    }

    @Override
    public void update() {
        System.out.println( "Hex String: "
                + Integer.toHexString( subject.getState() ).toUpperCase() );
    }
}

```

```java
public class ObserverPatternDemo {
    public static void main(String[] args) {
        Subject subject = new Subject();

        new HexaObserver(subject);
        new OctalObserver(subject);
        new BinaryObserver(subject);

        System.out.println("First state change : 15");
        subject.setState(15);
        System.out.println("Second state change : 10");
        subject.setState(10);
    }
}
/**
 * 输出结果：
 * First state change : 15
 * Hex String: F
 * Octal String: 17
 * Binary String: 1111
 * Second state change : 10
 * Hex String: A
 * Octal String: 12
 * Binary String: 1010
 */

```



##### 16. 迭代子模式(Iterator)

迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

**何时使用：**遍历一个聚合对象。

**应用实例：**JAVA 中的 iterator。

**实现**：

	我们将创建一个叙述导航方法的 *Iterator* 接口和一个返回迭代器的 *Container* 接口。实现了 *Container* 接口的实体类将负责实现 *Iterator* 接口。
	
	IteratorPatternDemo，我们的演示类使用实体类 *NamesRepository* 来打印 *NamesRepository* 中存储为集合的 *Names*。


``` java
public interface Iterator {
    boolean hasNext();
    Object next();
}
public interface Container {
    Iterator getIterator();
}

```

```java
//创建实现了 Container 接口的实体类。该类有实现了 Iterator 接口的内部类 NameIterator。
public class NameRepository implements Container {
    public String names[] = {"Robert" , "John" ,"Julie" , "Lora"};

    @Override
    public Iterator getIterator() {
        return new NameIterator();
    }

    private class NameIterator implements Iterator{

        int index;

        @Override
        public boolean hasNext() {
            if(index < names.length) {
                return true;
            }
            return false;
        }

        @Override
        public Object next() {
            if(this.hasNext()) {
                return names[index++];
            }
            return null;
        }
    }
}

```

```java
public class IteratorPatternDemo {
    public static void main(String[] args) {
        NameRepository nameRepository = new NameRepository();
        Iterator iter = nameRepository.getIterator();
        while(iter.hasNext()) {
            String name = (String) iter.next();
            System.out.println(name);
        }
    }
}
/**
 * 输出结果：
 * Robert
 * John
 * Julie
 * Lora
 */

```



##### 17. 责任链模式(Chain of Responsibility)

责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。

在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

**何时使用：**在处理消息的时候以过滤很多道。

**应用实例：** 1、红楼梦中的"击鼓传花"。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。

**实现**：

	我们创建抽象类 *AbstractLogger*，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 *AbstractLogger*。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。


```java
//创建抽象的记录器类。
public abstract class AbstractLogger {
    public static int INFO = 1;
    public static int DEBUG = 2;
    public static int ERROR = 3;

    protected int level;

    // 责任链的下一个元素
    protected AbstractLogger nextLogger;

    public void setNextLogger(AbstractLogger nextLogger) {
        this.nextLogger = nextLogger;
    }

    public void logMessage(int level, String message) {
        if(this.level < level) {
            write(message);
        }
        if(nextLogger != null) {
            nextLogger.logMessage(level, message);
        }
    }
	
    protected abstract void write(String message);
}

```

```java
//创建扩展了该记录器类的实体类。
public class ConsoleLogger extends AbstractLogger{
    public ConsoleLogger(int level) {
        this.level = level;
    }

    @Override
    protected void write(String message) {
        System.out.println("Standard Console :: Logger : " + message );
    }
}

public class ErrorLogger extends  AbstractLogger {
    public ErrorLogger(int level) {
        this.level = level;
    }

    @Override
    protected void write(String message) {
        System.out.println("Error Console :: logger : " + message);
    }
}

public class FileLogger extends AbstractLogger{
    public FileLogger(int level) {
        this.level = level;
    }

    @Override
    protected void write(String message) {
        System.out.println("File :: Logger : " + message);
    }
}

```

```java
//创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。
//每个记录器中的下一个记录器代表的是链的一部分。
public class ChainPatternDemo {
    private static AbstractLogger getChainLoggers() {
        AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);
        AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);
        AbstractLogger consolerLogger = new ConsoleLogger(AbstractLogger.INFO);

        errorLogger.setNextLogger(fileLogger);
        fileLogger.setNextLogger(consolerLogger);

        return errorLogger;
    }

    public static void main(String[] args) {
        AbstractLogger loggerChain = getChainLoggers();
        loggerChain.logMessage(AbstractLogger.INFO, "This is an information.");
        loggerChain.logMessage(AbstractLogger.DEBUG, "This is an debug level information.");
        loggerChain.logMessage(AbstractLogger.ERROR, "This is an error information.");
    }
}
/**
 * 输出结果：
 * Standard Console :: Logger : This is an debug level information.
 * File :: Logger : This is an error information.
 * Standard Console :: Logger : This is an error information.
 */

```



##### 18. 命令模式(Command)

命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。

**何时使用：**在某些场合，比如要对行为进行"记录、撤销/重做、事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将"行为请求者"与"行为实现者"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。

**应用实例：**struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。

**实现**：

	我们首先创建作为命令的接口 *Order*，然后创建作为请求的 *Stock* 类。实体命令类 *BuyStock* 和 *SellStock*，实现了 *Order* 接口，将执行实际的命令处理。创建作为调用对象的类 *Broker*，它接受订单并能下订单。
	
	*Broker* 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。*CommandPatternDemo*，我们的演示类使用 *Broker* 类来演示命令模式。


```java
public interface Order {
   void execute();
}

```

```java
// 创建一个 请求类
public class Stock {
   private String name = "ABC";
   private int quantity = 10;
 
   public void buy(){
      System.out.println("Stock [ Name: "+name+", 
         Quantity: " + quantity +" ] bought");
   }
   public void sell(){
      System.out.println("Stock [ Name: "+name+", 
         Quantity: " + quantity +" ] sold");
   }
}

```

```java
//创建实现了 Order 接口的实体类。
public class BuyStock implements Order {
   private Stock abcStock;
 
   public BuyStock(Stock abcStock){
      this.abcStock = abcStock;
   }
 
   public void execute() {
      abcStock.buy();
   }
}

public class SellStock implements Order {
   private Stock abcStock;
 
   public SellStock(Stock abcStock){
      this.abcStock = abcStock;
   }
 
   public void execute() {
      abcStock.sell();
   }
}

```

```java
public class Broker {
   private List<Order> orderList = new ArrayList<Order>(); 
 
   public void takeOrder(Order order){
      orderList.add(order);      
   }
 
   public void placeOrders(){
      for (Order order : orderList) {
         order.execute();
      }
      orderList.clear();
   }
}

```

```java
public class CommandPatternDemo {
   public static void main(String[] args) {
      Stock abcStock = new Stock();
 
      BuyStock buyStockOrder = new BuyStock(abcStock);
      SellStock sellStockOrder = new SellStock(abcStock);
 
      Broker broker = new Broker();
      broker.takeOrder(buyStockOrder);
      broker.takeOrder(sellStockOrder);
 
      broker.placeOrders();
   }
}

```



**类的状态**

##### 19. 备忘录模式(Memento)

备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。

**何时使用：**很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有"后悔药"可吃。

**应用实例：** 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。

**实现**：

	备忘录模式使用三个类 *Memento*、*Originator* 和 *CareTaker*。Memento 包含了要被恢复的对象的状态。Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。
	
	*MementoPatternDemo*，我们的演示类使用 *CareTaker* 和 *Originator* 对象来显示对象的状态恢复。


```java
public class Memento {
   private String state;
 
   public Memento(String state){
      this.state = state;
   }
 
   public String getState(){
      return state;
   }  
}

```

```java
public class Originator {
   private String state;
 
   public void setState(String state){
      this.state = state;
   }
 
   public String getState(){
      return state;
   }
 
   public Memento saveStateToMemento(){
      return new Memento(state);
   }
 
   public void getStateFromMemento(Memento Memento){
      state = Memento.getState();
   }
}

```

```java
public class CareTaker {
   private List<Memento> mementoList = new ArrayList<Memento>();
 
   public void add(Memento state){
      mementoList.add(state);
   }
 
   public Memento get(int index){
      return mementoList.get(index);
   }
}

```

```java
public class MementoPatternDemo {
   public static void main(String[] args) {
      Originator originator = new Originator();
      CareTaker careTaker = new CareTaker();
      originator.setState("State #1");
      originator.setState("State #2");
      careTaker.add(originator.saveStateToMemento());
      originator.setState("State #3");
      careTaker.add(originator.saveStateToMemento());
      originator.setState("State #4");
 
      System.out.println("Current State: " + originator.getState());    
      originator.getStateFromMemento(careTaker.get(0));
      System.out.println("First saved State: " + originator.getState());
      originator.getStateFromMemento(careTaker.get(1));
      System.out.println("Second saved State: " + originator.getState());
   }
}
/**
 * Current State: State #4
 * First saved State: State #2
 * Second saved State: State #3
 */

```



##### 20. 状态模式(State)

在状态模式（State Pattern）中，类的行为是基于它的状态改变的。

在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。

**何时使用：**代码中包含大量与对象状态有关的条件语句。

**应用实例：** 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，'钟是抽象接口','钟A'等是具体状态，'曾侯乙编钟'是具体环境（Context）。

**实现**：

	我们将创建一个 *State* 接口和实现了 *State* 接口的实体状态类。*Context* 是一个带有某个状态的类。
	
	*StatePatternDemo*，我们的演示类使用 *Context* 和状态对象来演示 Context 在状态改变时的行为变化。


```java
public interface State {
   public void doAction(Context context);
}

```

```java
public class StartState implements State {
 
   public void doAction(Context context) {
      System.out.println("Player is in start state");
      context.setState(this); 
   }
 
   public String toString(){
      return "Start State";
   }
}

public class StopState implements State {
 
   public void doAction(Context context) {
      System.out.println("Player is in stop state");
      context.setState(this); 
   }
 
   public String toString(){
      return "Stop State";
   }
}

```

```java
public class Context {
   private State state;
 
   public Context(){
      state = null;
   }
 
   public void setState(State state){
      this.state = state;     
   }
 
   public State getState(){
      return state;
   }
}

```

```java
// 使用 Context 来查看当状态 State 改变时的行为变化。
public class StatePatternDemo {
   public static void main(String[] args) {
      Context context = new Context();
 
      StartState startState = new StartState();
      startState.doAction(context);
 
      System.out.println(context.getState().toString());
 
      StopState stopState = new StopState();
      stopState.doAction(context);
 
      System.out.println(context.getState().toString());
   }
}
/**
 * Player is in start state
 * Start State
 * Player is in stop state
 * Stop State
 */

```



**通过中间类**

##### 21. 访问者模式(Vistor)

在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。

**何时使用：**需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，使用访问者模式将这些封装到类中。

**应用实例：**您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。

**实现**：

	我们将创建一个定义接受操作的 *ComputerPart* 接口。*Keyboard*、*Mouse*、*Monitor* 和 *Computer* 是实现了 *ComputerPart* 接口的实体类。我们将定义另一个接口 *ComputerPartVisitor*，它定义了访问者类的操作。*Computer* 使用实体访问者来执行相应的动作。
	
	*VisitorPatternDemo*，我们的演示类使用 *Computer*、*ComputerPartVisitor* 类来演示访问者模式的用法。


```java
public interface ComputerPart {
   public void accept(ComputerPartVisitor computerPartVisitor);
}

```

```java
public class Keyboard  implements ComputerPart { 
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      computerPartVisitor.visit(this);
   }
}

public class Monitor  implements ComputerPart { 
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      computerPartVisitor.visit(this);
   }
}

public class Mouse  implements ComputerPart { 
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      computerPartVisitor.visit(this);
   }
}

public class Computer implements ComputerPart {
   
   ComputerPart[] parts;
 
   public Computer(){
      parts = new ComputerPart[] {new Mouse(), new Keyboard(), new Monitor()};      
   } 
  
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      for (int i = 0; i < parts.length; i++) {
         parts[i].accept(computerPartVisitor);
      }
      computerPartVisitor.visit(this);
   }
}

```

```java
//访问者接口
public interface ComputerPartVisitor {
   public void visit(Computer computer);
   public void visit(Mouse mouse);
   public void visit(Keyboard keyboard);
   public void visit(Monitor monitor);
}

```

```java
// 访问者实现类
public class ComputerPartDisplayVisitor implements ComputerPartVisitor { 
   @Override
   public void visit(Computer computer) {
      System.out.println("Displaying Computer.");
   }
 
   @Override
   public void visit(Mouse mouse) {
      System.out.println("Displaying Mouse.");
   }
 
   @Override
   public void visit(Keyboard keyboard) {
      System.out.println("Displaying Keyboard.");
   }
 
   @Override
   public void visit(Monitor monitor) {
      System.out.println("Displaying Monitor.");
   }
}

```

```java
// 使用 ComputerPartDisplayVisitor 来显示 Computer 的组成部分。
public class VisitorPatternDemo {
   public static void main(String[] args) {
 
      ComputerPart computer = new Computer();
      computer.accept(new ComputerPartDisplayVisitor());
   }
}
//输出结果
//Displaying Mouse.
//Displaying Keyboard.
//Displaying Monitor.
//Displaying Computer.

```



##### 22. 中介者模式(Mediator)

中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。

**何时使用：**多个类相互耦合，形成了网状结构。

**应用实例：** 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。

**实现**：

	我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 *ChatRoom*和 *User*。*User* 对象使用 *ChatRoom* 方法来分享他们的消息。
	
	*MediatorPatternDemo*，我们的演示类使用 *User* 对象来显示他们之间的通信。```


```java
// 中介类
public class ChatRoom {
   public static void showMessage(User user, String message){
      System.out.println(new Date().toString()
         + " [" + user.getName() +"] : " + message);
   }
}

```

```java
// 用户通信
public class User {
   private String name;
 
   public String getName() {
      return name;
   }
 
   public void setName(String name) {
      this.name = name;
   }
 
   public User(String name){
      this.name  = name;
   }
 
   public void sendMessage(String message){
      ChatRoom.showMessage(this,message);
   }
}

```

```java
//使用 User 对象来显示他们之间的通信。
public class MediatorPatternDemo {
   public static void main(String[] args) {
      User robert = new User("Robert");
      User john = new User("John");
 
      robert.sendMessage("Hi! John!");
      john.sendMessage("Hello! Robert!");
   }
}
/**
 * 输出结果：
 * Thu Jan 31 16:05:46 IST 2013 [Robert] : Hi! John!
 * Thu Jan 31 16:05:46 IST 2013 [John] : Hello! Robert!
 */

```



##### 23. 解释器模式(Interpreter)

解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。

**何时使用：**如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。

**应用实例：**编译器、运算表达式计算。

**实现**：

	我们将创建一个接口 *Expression* 和实现了 *Expression* 接口的实体类。定义作为上下文中主要解释器的 *TerminalExpression* 类。其他的类 *OrExpression*、*AndExpression* 用于创建组合式表达式。
	
	*InterpreterPatternDemo*，我们的演示类使用 *Expression* 类创建规则和演示表达式的解析。


```java
// 新建表达式接口
public interface Expression {
   public boolean interpret(String context);
}

```

```java
// 表达式实现类
public class TerminalExpression implements Expression { 
   private String data;
 
   public TerminalExpression(String data){
      this.data = data; 
   }
 
   @Override
   public boolean interpret(String context) {
      if(context.contains(data)){
         return true;
      }
      return false;
   }
}

public class OrExpression implements Expression {
    
   private Expression expr1 = null;
   private Expression expr2 = null;
 
   public OrExpression(Expression expr1, Expression expr2) { 
      this.expr1 = expr1;
      this.expr2 = expr2;
   }
 
   @Override
   public boolean interpret(String context) {      
      return expr1.interpret(context) || expr2.interpret(context);
   }
}

public class AndExpression implements Expression {
    
   private Expression expr1 = null;
   private Expression expr2 = null;
 
   public AndExpression(Expression expr1, Expression expr2) { 
      this.expr1 = expr1;
      this.expr2 = expr2;
   }
 
   @Override
   public boolean interpret(String context) {      
      return expr1.interpret(context) && expr2.interpret(context);
   }
}

```

```java
public class InterpreterPatternDemo {
 
   //规则：Robert 和 John 是男性
   public static Expression getMaleExpression(){
      Expression robert = new TerminalExpression("Robert");
      Expression john = new TerminalExpression("John");
      return new OrExpression(robert, john);    
   }
 
   //规则：Julie 是一个已婚的女性
   public static Expression getMarriedWomanExpression(){
      Expression julie = new TerminalExpression("Julie");
      Expression married = new TerminalExpression("Married");
      return new AndExpression(julie, married);    
   }
 
   public static void main(String[] args) {
      Expression isMale = getMaleExpression();
      Expression isMarriedWoman = getMarriedWomanExpression();
 
      System.out.println("John is male? " + isMale.interpret("John"));
      System.out.println("Julie is a married women? " 
      + isMarriedWoman.interpret("Married Julie"));
   }
}
/**
 * 输出结果
 * John is male? true
 * Julie is a married women? true
 */

```















